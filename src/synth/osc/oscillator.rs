use std::collections::HashMap;

use crate::synth::{self, MIDI_TO_HZ};

use super::{wave::Waveform, *};

/// The basic sound-generation object for the application.
/// 
/// This `Oscillator` is implemented using a wavetable lookup method. Pregenerated values for a single cycle of each
/// possible [`Waveform`] are calculated at startup in [`osc::init_tables()`]. A phase value is maintained in order
/// to index into the appropriate table at different speeds based on the necessary frequency. This method prevents
/// each `Oscillator` from performing trigonometric calculations in real-time, which could be taxing with multiple
/// running at a sample rate of 44.1-48kHz, especially with more complicated [`Waveform`]s like the Saw wave.  
/// 
/// [`osc::init_tables()`]: init_tables()
pub struct Oscillator {
    /// Determines whether the `Oscillator` is "bypassed" - if true, it produces no signal.
    pub bypass: bool,
    /// Allows the frequency of the `Oscillator` to be modified by the amplitude
    /// of the signal from other `Oscillator`s via frequency modulation.
    fm_in: HashMap<usize, f64>,
    /// Determines the range by which an FM input can modulate the `Oscillator`'s frequency.
    fm_range: u16,
    /// The overall volume modifier of the signal. Stored in the struct, this field is measured as an
    /// amplitude multiplier, e.g. some value typically in the range `[0..1]`. However, when modified by
    /// user input, the public-facing value is measured in dB as that is more commonly used by audio
    /// professionals and musicians.
    gain: f64,
    /// The [`OutputMode`] describing the output target for this `Oscillator`'s signal. 
    output_mode: OutputMode,
    /// Modified and rounded to increment the index the `Oscillator` uses to access values from its [`Waveform`]'s
    /// corresponding table stored in [`osc`].
    /// 
    /// [`osc`]:    super
    phase: f64,
    /// A [`PitchController`] that handles calculation and modification of the `Oscillator`'s frequency
    /// (aside from FM).
    pitch_controller: PitchController,
    /// The sound wave shape generated by this `Oscillator`.
    waveform: Waveform,
}

impl Oscillator {
    /// Returns a new `Oscillator`.
    /// 
    /// Currently, none of the values are taken as arguments.
    pub fn new() -> Oscillator {
        Oscillator {
            bypass: true,
            fm_in: HashMap::new(),
            fm_range: 100,
            gain: 1.0,
            output_mode: OutputMode::Master,
            phase: 0.0,
            pitch_controller: PitchController::new(),
            waveform: Waveform::Sine,
        }
    }

    /// Calculates the current output sample for `self` in the form of an amplitude value `[-1.0..1.0]`.
    /// 
    /// If `self.bypass` is set to true, this value will be `0.0`. Otherwise, the `Oscillator` will apply any FM inputs,
    /// look up the appropriate sample value for its [`Waveform`], and increment its `phase`.
    /// 
    /// [`Constant`]:   PitchMode::Constant
    /// [`MIDI`]:       PitchMode::MIDI
    pub fn calc(&mut self) -> f64 {
        if self.bypass {
            return 0.0;
        }

        let mut frequency = self.pitch_controller.get_freq();

        let res = if self.waveform == Waveform::Noise {
            Waveform::Noise.calc(0.0, 0.0)
        } else {
            self.waveform.get_sample(self.phase)
        };

        // for frequency modulation
        self.fm_in.iter().for_each(|input| frequency += self.fm_range as f64 * input.1);

        // iterate to next sample/phase
        unsafe {
            let table_length = TABLE_LENGTH as f64;

            // frequency should not affect white noise
            if self.waveform == Waveform::Noise {
                self.phase += 1.0;
            } else {
                self.phase +=
                    frequency * table_length / synth::SAMPLE_RATE;
            }
            if self.phase >= table_length as f64 {
                self.phase -= table_length as f64;
            }
        }

        res * self.gain
    }

    /// Calls [`set_coarse()`] on `self.pitch_controller`.
    /// 
    /// [`set_coarse()`]:   PitchController::set_coarse()
    pub fn detune_coarse(&mut self, coarse: i32) {
        self.pitch_controller.set_coarse(coarse);
    }

    /// Calls [`set_fine()`] on `self.pitch_controller`.
    /// 
    /// [`set_fine()`]:     PitchController::set_fine()
    pub fn detune_fine(&mut self, fine: f64) {
        self.pitch_controller.set_fine(fine);
    }

    /// Returns the [`PitchMode`] of `self.pitch_controller`.
    pub fn get_mode(&self) -> PitchMode {
        self.pitch_controller.mode
    }

    /// Returns the [`OutputMode`] of `self`.
    pub fn get_output_mode(&self) -> OutputMode {
        self.output_mode
    }

    /// Sends a MIDI note-on signal to `self`.
    /// 
    /// Calls [`note_on()`] on `self.pitch_controller`. If there are no currently-held notes before this one,
    /// `self.phase` is reset to 0 in an attempt to reduce audio popping by placing the next sample at a
    /// zero-crossing.
    /// 
    /// This function assumes `self.pitch_controller.mode` has already been confirmed as [`PitchMode::MIDI`].
    /// 
    /// [`note_on()`]:  PitchController::note_on()
    pub fn note_on(&mut self, pitch: u8) {
        if self.pitch_controller.midi_notes.is_empty() {
            self.phase = 0.0;
        }
        self.pitch_controller.note_on(pitch);
    }

    /// Sends a MIDI note-off signal to `self`.
    /// 
    /// Calls [`note_off()`] on `self.pitch_controller`.
    /// 
    /// This function assumes `self.pitch_controller.mode` has already been confirmed as [`PitchMode::MIDI`].
    /// 
    /// [`note_off()`]: PitchController::note_off()
    pub fn note_off(&mut self, pitch: u8) {
        self.pitch_controller.note_off(pitch);
    }

    /// Inserts the `Oscillator` at `index` from the [`synth`] `oscs` vector if it doesn't already exist.
    pub fn add_fm_in(&mut self, index: usize) {
        if !self.fm_in.contains_key(&index) {
            self.fm_in.insert(index, 0.0);
        }
    }

    /// Passes a MIDI PitchBend message along to `self.pitch_controller`.
    pub fn pitch_bend(&mut self, lsb: u8, msb: u8) {
        self.pitch_controller.pitch_bend(lsb, msb);
    }

    /// Removes the `Oscillator` at `index` from `self.fm_in`.
    pub fn remove_fm_in(&mut self, index: usize) {
        self.fm_in.remove(&index);
    }

    /// Inputs the latest sample generated by the FM input at `index` for `self`'s next calculation.
    pub fn fm_sample_in(&mut self, index: usize, sample_in: f64) {
        if self.fm_in.contains_key(&index) {
            self.fm_in.insert(index, sample_in);
        }
    }

    /// Sets the `range` of possible modulation to `self.frequency` by the FM input.
    pub fn set_fm_range(&mut self, range: u16) {
        self.fm_range = range;
    }

    /// Calls [`set_freq()`] on `self.pitch_controller` to replace the frequency with the input `freq`.
    /// 
    /// [`set_freq()`]: PitchController::set_freq()
    pub fn set_freq(&mut self, freq: f64) {
        self.pitch_controller.set_freq(freq);
    }

    /// Modifies the `gain` property of `self`.
    /// 
    /// The value of the `gain_db` argument should be measured in dB. Often this value is between -60 and 0.
    /// The gain in dB will be converted to an amplitude modifier between 0.0 and 1.0 before assignment.
    pub fn set_gain(&mut self, gain_db: f64) {
        self.gain = synth::db_to_amp(gain_db);
    }

    /// Sets the [`PitchMode`] of `self.pitch_controller`.
    pub fn set_mode(&mut self, mode: PitchMode) {
        self.pitch_controller.set_mode(mode);
    }

    /// Replaces `self.output_mode` with `output`.
    pub fn set_output(&mut self, output: OutputMode) {
        self.output_mode = output;
    }

    /// Replaces `self.waveform` with `waveform`.
    pub fn set_waveform(&mut self, waveform: Waveform) {
        self.waveform = waveform;
    }
}


/// The mode in which an [`Oscillator`]'s [`PitchController`] should operate.
#[derive(Clone,Copy,Debug,PartialEq)]
pub enum PitchMode {
    /// The [`Oscillator`] will continuously produce a tone at a constant frequency.
    Constant,
    /// The [`Oscillator`] will produce sounds where the pitch is modified by MIDI signals.
    MIDI,
}

/// The target for an [`Oscillator`]'s output signal.
#[derive(Clone,Copy,Debug)]
pub enum OutputMode {
    /// The [`Oscillator`]'s audio is sent to the [`Mixer`].
    /// 
    /// [`Mixer`]:  crate::mixer::Mixer
    Master,
    /// The [`Oscillator`]'s signal modifies the frequency of another [`Oscillator`].
    Osc(usize),
}

/// Abstracts the implementation of an [`Oscillator`]'s frequency, the various ways it can be modified
/// by other parameters, and the calculations needed to maintain accurate information to generate audio samples.
struct PitchController {
    /// The most recently set base frequency for the [`Oscillator`], without modulations.
    base_frequency: f64,
    /// When in [`PitchMode::MIDI`] and all notes have been released, this field retains the value of the
    /// last-released pitch.
    last_pitch: u8,
    /// Keeps track of currently-held MIDI notes, allowing the pitch to return to the most recently pressed
    /// note when another is released.
    midi_notes: Vec<u8>,
    /// The [`PitchMode`] that describes where pitch information should be sourced from.
    mode: PitchMode,
    /// An amount of semitones in the range `[-12..12]` by which to adjust incoming MIDI pitches.
    offset_coarse: i8,
    /// An amount of cents in the range `[-0.5..0.5]` by which to adjust incoming MIDI pitches.
    offset_fine: f64,
    /// The amount of pitch bend, controlled by a MIDI controller, in the range `[-1.0..1.0]`.
    pitch_bend: f64,
}

impl PitchController {
    /// Returns a new `PitchController` with a [`PitchMode`] of [`MIDI`], a default frequency of
    /// 440Hz, and no pitch offset or bend.
    /// 
    /// [`MIDI`]:   PitchMode::MIDI
    fn new() -> PitchController {
        PitchController {
            base_frequency: 440.0,
            last_pitch: 69,
            midi_notes: vec![],
            mode: PitchMode::MIDI,
            offset_coarse: 0,
            offset_fine: 0.0,
            pitch_bend: 0.0,
        }
    }

    /// Calculates the frequency for the current output sample.
    /// 
    /// Called from [`Oscillator::calc()`]. 
    fn get_freq(&self) -> f64 {
        let freq = if self.mode == PitchMode::MIDI {
            let pitch = if !self.midi_notes.is_empty() {
                self.midi_notes[0] as i8 + self.offset_coarse
            } else {
                self.last_pitch as i8 + self.offset_coarse
            };

            if self.offset_fine != 0.0 {
                440.0 * f64::powf(2.0, (pitch as f64 + self.offset_fine - 69.0) / 12.0)
            } else {
                MIDI_TO_HZ[(pitch as usize).max(0).min(127)]
            }
        } else {
            self.base_frequency
        };

        freq * f64::powf(2_f64, self.pitch_bend * 2_f64 / 12_f64)
    }

    /// Sends the MIDI NoteOn signal to the `PitchController`.
    fn note_on(&mut self, pitch: u8) {
        if !self.midi_notes.contains(&pitch) {
            self.midi_notes.insert(0, pitch);
            self.base_frequency = MIDI_TO_HZ[pitch as usize];
        }
    }

    /// Sends the MIDI NoteOff signal to the `PitchController`.
    fn note_off(&mut self, pitch: u8) {
        for i in 0..self.midi_notes.len() {
            if self.midi_notes[i] == pitch {
                self.midi_notes.remove(i);
                break;
            }
        }
        if !self.midi_notes.is_empty() {
            self.base_frequency = MIDI_TO_HZ[self.midi_notes[0] as usize];
        } else {
            self.last_pitch = pitch;
        }
    }

    /// Sets `self.pitch_bend` value.
    /// 
    /// To convert the MIDI bytes to one number, `msb` is shifted 7 bits to the left,
    /// then combined with `lsb` via bitwise OR.
    fn pitch_bend(&mut self, lsb: u8, msb: u8) {
        let mut pitch_bend: u16 = (msb as u16) << 7;
        pitch_bend |= (lsb as u16);
        self.pitch_bend = (pitch_bend as f64 - 8192_f64) / 8191_f64;
    }

    /// Restricts `coarse` to the range `[-12..12]`, then replaces `self.offset_coarse`.
    fn set_coarse(&mut self, coarse: i32) {
        let coarse = coarse.max(-12).min(12) as i8;
        self.offset_coarse = coarse;
    }

    /// Restricts `fine` to the range `[-0.5..0.5]`, then replaces `self.offset_fine`.
    fn set_fine(&mut self, fine: f64) {
        let fine = fine.max(-0.5).min(0.5);
        self.offset_fine = fine;
    }

    fn set_freq(&mut self, freq: f64) {
        self.base_frequency = freq;
    }

    fn set_mode(&mut self, mode: PitchMode) {
        self.mode = mode;
    }
}

#[cfg(test)]
mod pitch_control_tests {
    use super::*;

    // Checks that the `PitchController` (in `PitchMode::MIDI` by default) correctly translates a
    // default `last_pitch` of 69 to a frequency of 440Hz.
    #[test]
    fn first_freq_is_440() {
        let pitch_controller = PitchController::new();
        let freq = pitch_controller.get_freq();

        assert_eq!(freq, 440.0)
    }

    #[test]
    fn constant_mode_ignores_pitch_detune() {
        let mut pitch_controller = PitchController::new();
        pitch_controller.set_coarse(12);
        pitch_controller.set_fine(-0.25);
        pitch_controller.set_mode(PitchMode::Constant);

        let freq = pitch_controller.get_freq();

        assert_eq!(freq, 440.0)
    }

    #[test]
    fn byte_conversion_is_correct() {
        let mut pitch_controller = PitchController::new();

        // Should be a value of 8192/no bend, according to MIDI protocol:
        pitch_controller.pitch_bend(0, 64);
        let res = pitch_controller.pitch_bend;
        assert_eq!(res, 0_f64);

        pitch_controller.pitch_bend(1, 0);
        let res = pitch_controller.pitch_bend;
        assert_eq!(res, -1_f64);

        pitch_controller.pitch_bend(127, 127);
        let res = pitch_controller.pitch_bend;
        assert_eq!(res, 1_f64);
    }
}