use crate::synth;

use super::{wave::Waveform, *};

/// The basic sound-generation object for the application.
/// 
/// This `Oscillator` is implemented using a wavetable lookup method. Pregenerated values for a single cycle of each
/// possible [`Waveform`] are calculated at startup in [`osc::init_tables()`]. A phase value is maintained in order
/// to index into the appropriate table at different speeds based on the necessary frequency. This method prevents
/// each `Oscillator` from performing trigonometric calculations in real-time, which could be taxing with multiple
/// running at a sample rate of 44.1-48kHz, especially with more complicated [`Waveform`]s like the Saw wave.  
/// 
/// [`osc::init_tables()`]: init_tables()
pub struct Oscillator {
    /// Determines whether the `Oscillator` is "bypassed" - if true, it produces no signal.
    pub bypass: bool,
    /// Currently unused. The type of this field might change with implementation. In theory, this will
    /// allow the `frequency` (or possibly other fields) of an `Oscillator` to be modified by the amplitude
    /// of the signal from another `Oscillator` via frequency modulation.
    fm: Option<Box<Oscillator>>,
    /// Currently unused. Determines the range by which an FM input can modulate one of the `Oscillator`'s values.
    fm_range: u16,
    /// The frequency, in Hz, produced by this `Oscillator`. When an FM input is active, this is treated as a base
    /// value for modulation and does not directly change.
    frequency: f64,
    /// The overall volume modifier of the signal. Stored in the struct, this field is measured as an
    /// amplitude multiplier, e.g. some value typically in the range `[0..1]`. However, when modified by
    /// user input, the public-facing value is measured in dB as that is more commonly used by audio
    /// professionals and musicians.
    gain: f64,
    /// Keeps track of the actively held MIDI pitches, allowing the `Oscillator` to return to the most recently pressed,
    /// still-held pitch when the one corresponding to the current frequency is released.
    midi_notes: Vec<u8>,
    /// Determines which [`OscMode`] the `Oscillator` is in.
    mode: OscMode,
    /// Modified and rounded to increment the index the `Oscillator` uses to access values from its [`Waveform`]'s
    /// corresponding table stored in [`osc`].
    /// 
    /// [`osc`]:    super
    phase: f64,
    /// The sound wave shape generated by this `Oscillator`.
    waveform: Waveform,
}

impl Oscillator {
    /// Returns a new `Oscillator`.
    /// 
    /// Currently, none of the values are taken as arguments.
    pub fn new() -> Oscillator {
        Oscillator {
            bypass: true,
            fm: None,
            fm_range: 100,
            frequency: 440.0,
            gain: 1.0,
            midi_notes: vec![],
            mode: OscMode::MIDI,
            phase: 0.0,
            waveform: Waveform::Sine,
        }
    }

    /// Calculates the current output sample for `self`.
    /// 
    /// If `self.bypass` is set to true, this value will be `0.0`. Otherwise, the `Oscillator` will look up
    /// the appropriate sample value for its [`Waveform`], increment its `phase`, and then apply any multipliers
    /// offered by its [`Amplifier`]. If `self` is in [`Constant`] mode, this will only be the overall `gain` value,
    /// whereas in [`MIDI`] mode, [`Amplifier::calc()`] is called to shape the amplitude based on MIDI information.
    /// 
    /// [`Constant`]:   OscMode::Constant
    /// [`MIDI`]:   OscMode::MIDI
    pub fn calc(&mut self) -> f64 {
        if self.bypass {
            return 0.0;
        }

        let mut frequency = self.frequency;

        let res = if self.waveform == Waveform::Noise {
            Waveform::Noise.calc(0.0, 0.0)
        } else {
            self.waveform.get_sample(self.phase)
        };

        // for frequency modulation
        if let Some(ref mut osc) = &mut self.fm {
            frequency += (self.fm_range / 2) as f64 * osc.calc();
        }

        // iterate to next sample/phase
        unsafe {
            let table_length = TABLE_LENGTH as f64;

            // frequency should not affect white noise
            if self.waveform == Waveform::Noise {
                self.phase += 1.0;
            } else {
                self.phase +=
                    frequency * table_length / crate::SAMPLE_RATE;
            }
            if self.phase >= table_length as f64 {
                self.phase -= table_length as f64;
            }
        }

        res * self.gain
    }

    /// Returns the [`OscMode`] of `self`.
    pub fn get_mode(&self) -> OscMode {
        self.mode
    }

    /// Sends a MIDI note-on signal to `self`.
    /// 
    /// The note stored in `pitch` is added to `self.midi_notes`, and `self.frequency` is converted
    /// from its MIDI pitch `[0..127]` to Hz. If this is the only note being held, `phase` is set to
    /// 0.0 - in theory, the 0th value of any of the [`Waveform`]s should be a zero-crossing, or close
    /// to one, which should help prevent "popping" when notes are triggered with an attack time of 0.
    pub fn note_on(&mut self, pitch: u8) {
        if self.midi_notes.is_empty() {
            self.phase = 0.0;
        }
        if !self.midi_notes.contains(&pitch) {
            self.midi_notes.insert(0, pitch);
            unsafe {
                self.set_freq(synth::MIDI_TO_HZ[pitch as usize]);
            }
        }
    }

    /// Sends a MIDI note-off signal to `self`.
    /// 
    /// The `pitch` is removed from `self.midi_notes`. If other notes are still held, `self.frequency`
    /// is set to the most recently pressed still-held note.
    pub fn note_off(&mut self, pitch: u8) {
        for i in 0..self.midi_notes.len() {
            if self.midi_notes[i] == pitch {
                self.midi_notes.remove(i);
                break;
            }
        }
        if !self.midi_notes.is_empty() {
            unsafe {
                self.set_freq(synth::MIDI_TO_HZ[self.midi_notes[0] as usize]);
            }
        }
    }

    /// Sets `osc` as the FM input to `self`. Input `osc` as `None` to remove the FM input.
    /// 
    /// Currently unused.
    pub fn set_fm(&mut self, osc: Option<Oscillator>) {
        if let Some(osc) = osc {
            self.fm = Some(Box::new(osc));
        } else {
            self.fm = None;
        }
    }

    /// Sets the `range` of possible modulation to `self.frequency` by the FM input.
    pub fn set_fm_range(&mut self, range: u16) {
        self.fm_range = range;
    }

    /// Replaces `self.frequency` with `freq`.
    pub fn set_freq(&mut self, freq: f64) {
        self.frequency = freq;
    }

    /// Modifies the `gain` property of `self`.
    /// 
    /// The value of the `gain_db` argument should be measured in dB. Often this value is between -60 and 0.
    /// The gain in dB will be converted to an amplitude modifier between 0.0 and 1.0 before assignment.
    pub fn set_gain(&mut self, gain_db: f64) {
        self.gain = synth::db_to_amp(gain_db);
    }

    /// Replaces `self.mode` with `mode`.
    pub fn set_mode(&mut self, mode: OscMode) {
        self.mode = mode;
    }

    /// Replaces `self.waveform` with `waveform`.
    pub fn set_waveform(&mut self, waveform: Waveform) {
        self.waveform = waveform;
    }
}

/// The mode in which an [`Oscillator`] should operate.
#[derive(Clone,Copy,Debug,PartialEq)]
pub enum OscMode {
    /// The [`Oscillator`] will continuously produce a tone at a constant frequency.
    Constant,
    /// The [`Oscillator`] will produce sounds where the pitch is modified by MIDI signals.
    MIDI,
}