use std::collections::HashMap;

use crate::synth;

use super::{wave::Waveform, *};

/// The basic sound-generation object for the application.
/// 
/// This `Oscillator` is implemented using a wavetable lookup method. Pregenerated values for a single cycle of each
/// possible [`Waveform`] are calculated at startup in [`osc::init_tables()`]. A phase value is maintained in order
/// to index into the appropriate table at different speeds based on the necessary frequency. This method prevents
/// each `Oscillator` from performing trigonometric calculations in real-time, which could be taxing with multiple
/// running at a sample rate of 44.1-48kHz, especially with more complicated [`Waveform`]s like the Saw wave.  
/// 
/// [`osc::init_tables()`]: init_tables()
pub struct Oscillator {
    /// Determines whether the `Oscillator` is "bypassed" - if true, it produces no signal.
    pub bypass: bool,
    /// Allows the `frequency` of the `Oscillator` to be modified by the amplitude
    /// of the signal from other `Oscillator`s via frequency modulation.
    fm_in: HashMap<usize, f64>,
    /// Determines the range by which an FM input can modulate one of the `Oscillator`'s values.
    fm_range: u16,
    /// The frequency, in Hz, produced by this `Oscillator`. When an FM input is active, this is treated as a base
    /// value for modulation and does not directly change.
    frequency: f64,
    /// The overall volume modifier of the signal. Stored in the struct, this field is measured as an
    /// amplitude multiplier, e.g. some value typically in the range `[0..1]`. However, when modified by
    /// user input, the public-facing value is measured in dB as that is more commonly used by audio
    /// professionals and musicians.
    gain: f64,
    /// Keeps track of the actively held MIDI pitches, allowing the `Oscillator` to return to the most recently pressed,
    /// still-held pitch when the one corresponding to the current frequency is released.
    midi_notes: Vec<u8>,
    /// Determines which [`OscMode`] the `Oscillator` is in.
    mode: OscMode,
    /// The [`OutputMode`] describing the output target for this `Oscillator`'s signal. 
    output: OutputMode,
    /// Modified and rounded to increment the index the `Oscillator` uses to access values from its [`Waveform`]'s
    /// corresponding table stored in [`osc`].
    /// 
    /// [`osc`]:    super
    phase: f64,
    /// The [`PitchOffset`] describing the `Oscillator`'s pitch relative to the current MIDI note: e.g., an `Oscillator`
    /// can be programmed to play a major third below whatever note is being held. By default, both values are `0`.
    pitch_offset: PitchOffset,
    /// The sound wave shape generated by this `Oscillator`.
    waveform: Waveform,
}

impl Oscillator {
    /// Returns a new `Oscillator`.
    /// 
    /// Currently, none of the values are taken as arguments.
    pub fn new() -> Oscillator {
        Oscillator {
            bypass: true,
            fm_in: HashMap::new(),
            fm_range: 100,
            frequency: 440.0,
            gain: 1.0,
            midi_notes: vec![],
            mode: OscMode::MIDI,
            output: OutputMode::Master,
            phase: 0.0,
            pitch_offset: PitchOffset{ coarse: 0, fine: 0.0 },
            waveform: Waveform::Sine,
        }
    }

    /// Calculates the current output sample for `self`.
    /// 
    /// If `self.bypass` is set to true, this value will be `0.0`. Otherwise, the `Oscillator` will look up
    /// the appropriate sample value for its [`Waveform`], increment its `phase`, and then apply any multipliers
    /// offered by its [`Amplifier`]. If `self` is in [`Constant`] mode, this will only be the overall `gain` value,
    /// whereas in [`MIDI`] mode, [`Amplifier::calc()`] is called to shape the amplitude based on MIDI information.
    /// 
    /// [`Constant`]:   OscMode::Constant
    /// [`MIDI`]:   OscMode::MIDI
    pub fn calc(&mut self) -> f64 {
        if self.bypass {
            return 0.0;
        }

        let mut frequency = self.frequency;

        let res = if self.waveform == Waveform::Noise {
            Waveform::Noise.calc(0.0, 0.0)
        } else {
            self.waveform.get_sample(self.phase)
        };

        // for frequency modulation
        self.fm_in.iter().for_each(|input| frequency += self.fm_range as f64 * input.1);

        // iterate to next sample/phase
        unsafe {
            let table_length = TABLE_LENGTH as f64;

            // frequency should not affect white noise
            if self.waveform == Waveform::Noise {
                self.phase += 1.0;
            } else {
                self.phase +=
                    frequency * table_length / crate::SAMPLE_RATE;
            }
            if self.phase >= table_length as f64 {
                self.phase -= table_length as f64;
            }
        }

        res * self.gain
    }

    /// Returns the [`OscMode`] of `self`.
    pub fn get_mode(&self) -> OscMode {
        self.mode
    }

    /// Returns the [`OutputMode`] of `self`.
    pub fn get_output(&self) -> OutputMode {
        self.output
    }

    /// Sends a MIDI note-on signal to `self`.
    /// 
    /// The note stored in `pitch` is added to `self.midi_notes`, and `self.frequency` is converted
    /// from its MIDI pitch `[0..127]` to Hz. If this is the only note being held, `phase` is set to
    /// 0.0 - in theory, the 0th value of any of the [`Waveform`]s should be a zero-crossing, or close
    /// to one, which should help prevent "popping" when notes are triggered with an attack time of 0.
    /// 
    /// This function assumes it has been called after already checking that `self.mode` is [`OscMode::MIDI`].
    pub fn note_on(&mut self, pitch: u8) {
        if self.midi_notes.is_empty() {
            self.phase = 0.0;
        }
        if !self.midi_notes.contains(&pitch) {
            self.midi_notes.insert(0, pitch);
            let freq = self.freq_from_offset(pitch);
            self.set_freq(freq);
        }
    }

    /// Sends a MIDI note-off signal to `self`.
    /// 
    /// The `pitch` is removed from `self.midi_notes`. If other notes are still held, `self.frequency`
    /// is set to the most recently pressed still-held note.
    /// 
    /// This function assumes it has been called after already checking that `self.mode` is [`OscMode::MIDI`].
    pub fn note_off(&mut self, pitch: u8) {
        for i in 0..self.midi_notes.len() {
            if self.midi_notes[i] == pitch {
                self.midi_notes.remove(i);
                break;
            }
        }
        if !self.midi_notes.is_empty() {
            let freq = self.freq_from_offset(self.midi_notes[0]);
            self.set_freq(freq);
        }
    }

    /// Converts a MIDI pitch into a frequency after applying the values of `self.pitch_offset`.
    fn freq_from_offset(&mut self, pitch: u8) -> f64 {
        let mut pitch = pitch as i32 + self.pitch_offset.coarse;
        pitch = pitch.min(127).max(0);

        unsafe {
            if self.pitch_offset.fine == 0.0 {
                synth::MIDI_TO_HZ[pitch as usize]
            } else {
                440.0 * f64::powf(2.0, (pitch as f64 + self.pitch_offset.fine - 69.0) / 12.0)
            }
        }
    }

    /// Sets the detune value `self.pitch_offset.coarse` to `coarse`, constraining it to the range
    /// `[-12..12]`.
    pub fn set_coarse_detune(&mut self, coarse: i32) {
        self.pitch_offset.coarse = coarse.min(12).max(-12);
        if self.mode == OscMode::MIDI && !self.midi_notes.is_empty() {
            let freq = self.freq_from_offset(self.midi_notes[0]);
            self.set_freq(freq);
        }
    }

    /// Sets the detune value `self.pitch_offset.fine` to `fine`, constraining it to the range `[-0.5..0.5]`.
    pub fn set_fine_detune(&mut self, fine: f64) {
        self.pitch_offset.fine = fine.min(0.5).max(-0.5);
        if self.mode == OscMode::MIDI && !self.midi_notes.is_empty() {
            let freq = self.freq_from_offset(self.midi_notes[0]);
            self.set_freq(freq);
        }
    }

    /// Inserts the `Oscillator` at `index` from the [`synth`] `oscs` vector if it doesn't already exist.
    pub fn add_fm_in(&mut self, index: usize) {
        if !self.fm_in.contains_key(&index) {
            self.fm_in.insert(index, 0.0);
        }
    }

    /// Removes the `Oscillator` at `index` from `self.fm_in`.
    pub fn remove_fm_in(&mut self, index: usize) {
        self.fm_in.remove(&index);
    }

    /// Inputs the latest sample generated by the FM input at `index` for `self`'s next calculation.
    pub fn fm_sample_in(&mut self, index: usize, sample_in: f64) {
        if self.fm_in.contains_key(&index) {
            self.fm_in.insert(index, sample_in);
        }
    }

    /// Sets the `range` of possible modulation to `self.frequency` by the FM input.
    pub fn set_fm_range(&mut self, range: u16) {
        self.fm_range = range;
    }

    /// Replaces `self.frequency` with `freq`.
    pub fn set_freq(&mut self, freq: f64) {
        self.frequency = freq;
    }

    /// Modifies the `gain` property of `self`.
    /// 
    /// The value of the `gain_db` argument should be measured in dB. Often this value is between -60 and 0.
    /// The gain in dB will be converted to an amplitude modifier between 0.0 and 1.0 before assignment.
    pub fn set_gain(&mut self, gain_db: f64) {
        self.gain = synth::db_to_amp(gain_db);
    }

    /// Replaces `self.mode` with `mode`.
    pub fn set_mode(&mut self, mode: OscMode) {
        self.mode = mode;
    }

    /// Replaces `self.output` with `output`.
    pub fn set_output(&mut self, output: OutputMode) {
        self.output = output;
    }

    /// Replaces `self.waveform` with `waveform`.
    pub fn set_waveform(&mut self, waveform: Waveform) {
        self.waveform = waveform;
    }
}


/// The mode in which an [`Oscillator`] should operate.
#[derive(Clone,Copy,Debug,PartialEq)]
pub enum OscMode {
    /// The [`Oscillator`] will continuously produce a tone at a constant frequency.
    Constant,
    /// The [`Oscillator`] will produce sounds where the pitch is modified by MIDI signals.
    MIDI,
}

/// The target for an [`Oscillator`]'s output signal.
#[derive(Clone,Copy,Debug)]
pub enum OutputMode {
    /// The [`Oscillator`]'s audio is sent to the [`Mixer`].
    /// 
    /// [`Mixer`]:  crate::mixer::Mixer
    Master,
    /// The [`Oscillator`]'s signal modifies the frequency of another [`Oscillator`].
    Osc(usize),
}

/// The oscillator's offset from the current MIDI pitch, if in [`OscMode::MIDI`].
struct PitchOffset {
    /// An amount of semitones in the range `[-12..12]`.
    coarse: i32,
    /// An amount of cents in the range `[-0.5..0.5]`.
    fine: f64,
}